<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>VanJS Outliner with Editable Notes</title>
    <style>
        .container {
            display: flex;
            width: 100%;
            height: 100vh;
        }
        .outline {
            width: 30%;
            padding: 10px;
            border-right: 1px solid #ccc;
            overflow-y: auto;
        }
        .notes {
            width: 70%;
            padding: 10px;
            overflow-y: auto;
        }
        .note-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }
        .tab-container {
            margin-top: 10px;
        }
        .tab {
            display: inline-block;
            padding: 5px 10px;
            margin: 0 2px;
            border: 1px solid #ccc;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            background-color: #f0f0f0;
        }
        .active-tab {
            background-color: #e0e0e0;
            font-weight: bold;
        }
        .node {
            display: flex;
            align-items: center;
        }
        .node > span, .node > input {
            margin-left: 5px;
        }
        .note-content {
            width: calc(100% - 12px); /* Adjust width to fit the content area */
            height: calc(100vh - 120px); /* Adjust height based on available space */
            margin-top: 0;
            border: 1px solid #ccc;
            box-sizing: border-box;
            overflow-y: auto;
        }
        .actions {
            margin-left: 5px;
            font-size: 12px;
        }
        .icon {
            cursor: pointer;
            margin-left: 5px;
            text-decoration: none;
            color: black;
        }
        ul {
            list-style-type: none;
            padding-left: 0;
        }
        li {
            margin-bottom: 5px;
        }
        .menu {
            position: absolute;
            top: 30px;
            left: 10px;
            border: 1px solid #ccc;
            background-color: #fff;
            padding: 5px;
            display: none; /* Hidden by default */
            z-index: 1;
        }
        .menu a {
            display: block;
            padding: 5px 10px;
            text-decoration: none;
            color: black;
            cursor: pointer;
        }
        .menu a:hover {
            background-color: #f0f0f0;
        }
    </style>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/vanjs-org/van/public/van-1.5.2.nomodule.min.js"></script>
</head>
<body>
<script>
    const {div, button, ul, li, span, textarea, input, a} = van.tags;

    // State for the outline tree structure and notes
    const tree = van.state([]);
    const selectedNode = van.state(null);
    const editingNodeIndex = van.state(null);  // Track the node being edited
    const menuVisible = van.state(false);  // State to control menu visibility

    // Function to add a new child node
    const addNode = (parentNode) => {
        const newNode = { name: `Node ${parentNode.children.length + 1}`, children: [], notes: [], expanded: true };
        parentNode.children.push(newNode);
        tree.val = [...tree.val];  // Trigger re-render by reassigning the state
    };

    // Function to remove a node safely
    const removeNode = (nodeToRemove, parentNode = null) => {
        if (!parentNode) {
            // Remove the node from the root level
            tree.val = tree.val.filter(node => node !== nodeToRemove);
        } else {
            // Remove the node from its parent's children
            parentNode.children = parentNode.children.filter(node => node !== nodeToRemove);
        }
        tree.val = [...tree.val];  // Trigger re-render
    };

    // Function to select a node
    const selectNode = (node) => selectedNode.val = node;

    // Function to toggle expand/collapse state
    const toggleExpand = (node) => {
        node.expanded = !node.expanded;
        tree.val = [...tree.val];  // Trigger re-render
    };

    // Function to toggle the menu visibility
    const toggleMenu = () => menuVisible.val = !menuVisible.val;

    // Function to handle menu actions
    const handleMenuAction = (action) => {
        switch(action) {
            case "Open":
                openFile();
                break;
            case "Save":
                saveFile();
                break;
        }
        menuVisible.val = false;  // Hide menu after an action
    };

    // Function to convert the tree state to a JSON string
    const getTreeData = () => JSON.stringify(tree.val, null, 2);

    // Updated saveFile function with filename prompt
    const saveFile = () => {
        // Prompt the user to enter a filename
        const filename = prompt("Enter filename for saving:", "outliner.json");
        
        // If a filename is provided, proceed with saving
        if (filename) {
            const blob = new Blob([getTreeData()], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename; // Use the filename provided by the user
            a.click();
            URL.revokeObjectURL(url); // Clean up the object URL
        }
    };

    // Function to handle file selection and read its content
    const openFile = () => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "application/json";
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        tree.val = data;
                        selectedNode.val = null; // Clear selected node after opening file
                    } catch (error) {
                        alert("Failed to parse JSON file.");
                    }
                };
                reader.readAsText(file);
            }
        };
        input.click();
    };

    // Recursive function to render the tree nodes
    const renderTree = (nodes, parentNode = null, depth = 0) => ul(
        nodes.map((node, index) =>
            li(
                div({
                        class: "node",
                        style: `padding-left: ${depth * 20}px;`  // Indentation based on depth
                    },
                    node.children.length > 0 ? a({
                            href: "#", class: "icon", title: node.expanded ? "Collapse" : "Expand",
                            onclick: (e) => (e.preventDefault(), toggleExpand(node))
                        },
                        // Using innerHTML for expand/collapse icons
                        div({innerHTML: node.expanded ? `
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>` : `
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="9 18 15 12 9 6"></polyline>
                            </svg>`
                        })) : "",
                    span(" "), // Space between icon and node name
                    node.notes.length > 0 ? span("📄") : "",  // Document icon if the node has notes
                    editingNodeIndex.val === node ? input({
                        type: "text",
                        value: node.name,
                        oninput: (e) => {
                            node.name = e.target.value;  // Update the node name without re-render
                        },
                        onblur: () => {
                            editingNodeIndex.val = null;  // Exit edit mode on blur
                            tree.val = [...tree.val];  // Trigger re-render after editing
                        },
                        onkeypress: (e) => {  // Exit edit mode on Enter key
                            if (e.key === 'Enter') {
                                editingNodeIndex.val = null;
                                tree.val = [...tree.val];  // Trigger re-render after editing
                            }
                        }
                    }) : span(
                        {
                            ondblclick: () => editingNodeIndex.val = node,  // Double-click to enter edit mode for the correct node
                            onclick: () => selectNode(node),
                            style: () => selectedNode.val === node ? "font-weight: bold; cursor: pointer;" : "cursor: pointer;"
                        },
                        node.name
                    ),
                    selectedNode.val === node ? div({class: "actions"},
                        a({
                            href: "#", class: "icon", title: "Add Child",
                            onclick: (e) => (e.preventDefault(), addNode(node))
                        }, "➕"),
                        a({
                            href: "#", class: "icon", title: "Remove Node",
                            onclick: (e) => (e.preventDefault(), removeNode(node, parentNode))
                        }, "❌")
                    ) : ""
                ),
                node.children.length > 0 && node.expanded ? renderTree(node.children, node, depth + 1) : null
            )
        )
    );

    // Function to add a new note tab for the selected node
    const addNoteTab = () => {
        if (!selectedNode.val) return;  // No node selected
        selectedNode.val.notes.push({ tabName: `Note ${selectedNode.val.notes.length + 1}`, content: "" });
        selectedNode.val = { ...selectedNode.val };  // Ensure selectedNode state is updated
        tree.val = [...tree.val];  // Trigger re-render of the tree
    };

    // Function to render the right notes column
    const Notes = () => {
        const selectedTabIndex = van.state(0);
        const editingTabIndex = van.state(-1);  // Keeps track of the editing tab

        return () => {
            if (!selectedNode.val) {
                return div("No Node Selected");
            }

            const notes = selectedNode.val.notes;

            return div(
                div({class: "note-header"},
                    span({style: "font-weight: bold; font-size: 16px;"}, selectedNode.val.name),
                    button({onclick: addNoteTab}, "Add Note Tab")
                ),
                div(
                    notes.length > 0 ?
                        notes.map((note, index) =>
                            span(
                                {
                                    class: () => selectedTabIndex.val === index ? "tab active-tab" : "tab",
                                    ondblclick: () => {
                                        editingTabIndex.val = index;  // Double-click to enter edit mode
                                    },
                                    onclick: () => {
                                        if (editingTabIndex.val !== index) {  // Only change selection if not editing
                                            selectedTabIndex.val = index;
                                        }
                                    }
                                },
                                editingTabIndex.val === index ? input({
                                    type: "text",
                                    value: note.tabName,
                                    oninput: (e) => {
                                        note.tabName = e.target.value;  // Update the tab name without re-render
                                    },
                                    onblur: () => {
                                        editingTabIndex.val = -1;  // Exit edit mode on blur
                                        selectedNode.val.notes[index] = {...note};  // Reassign the note to trigger reactivity
                                        selectedNode.val = { ...selectedNode.val };  // Re-render only after editing is complete
                                    },
                                    onkeypress: (e) => {  // Exit edit mode on Enter key
                                        if (e.key === 'Enter') {
                                            editingTabIndex.val = -1;
                                            selectedNode.val.notes[index] = {...note};  // Reassign the note to trigger reactivity
                                            selectedNode.val = { ...selectedNode.val };  // Re-render only after editing is complete
                                        }
                                    }
                                }) : note.tabName
                            )
                        )
                        : ""
                ),
                div(
                    {
                        class: "tab-container"
                    },
                    () => notes[selectedTabIndex.val] ?
                        textarea({
                            class: "note-content",
                            value: notes[selectedTabIndex.val].content,
                            oninput: (e) => {
                                notes[selectedTabIndex.val].content = e.target.value;  // Update the note content without re-render
                            }
                        }) : ""
                )
            );
        };
    };

    // Function to handle menu blur
    const handleMenuBlur = (e) => {
        setTimeout(() => {
            if (!document.querySelector(".menu:hover") && !e.target.closest(".menu")) {
                menuVisible.val = false;  // Hide menu if not hovering over it and click outside
            }
        }, 100);
    };

    // Main container to hold both columns
    const App = () => div(
        {class: "container"},
        div(
            {class: "outline"},
            // Menu icon and dropdown
            div(
                {
                    style: "margin-bottom: 10px; position: relative;"
                },
                a({
                    href: "#", onclick: (e) => (e.preventDefault(), toggleMenu())
                },
                div({innerHTML: `
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="3" y1="12" x2="21" y2="12"></line>
                        <line x1="3" y1="6" x2="21" y2="6"></line>
                        <line x1="3" y1="18" x2="21" y2="18"></line>
                    </svg>`
                })),
                div({class: "menu", style: () => menuVisible.val ? "display: block;" : "display: none;"},
                    a({onclick: () => handleMenuAction("Open")}, "Open"),
                    a({onclick: () => handleMenuAction("Save")}, "Save")
                )
            ),
            () => renderTree(tree.val)
        ),
        div({class: "notes"}, Notes())
    );

    // Attach blur event handler to the document
    document.addEventListener('mousedown', handleMenuBlur);

    // Initialize the tree with a root node
    tree.val = [{ name: 'Root Node', children: [], notes: [], expanded: true }];

    van.add(document.body, App());
</script>
</body>
</html>
